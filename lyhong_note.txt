power stat相关文件层级关系：
    gpu-sim.cc -> power_interface.cc -> gpgpu_sim_wrapper.cc -> processor.cc -> core.cc

power_interface.cc 中在采样accelsim仿真得到的指令数据等信息，然后通过汇总数据和一些函数计算出相应的power信息。
    但貌似在power_interface.cc 部分，并不知道具体的活跃核心分布，其通过采样某些数据量，除以周期数得到近似的空闲核心数量

ipc 在gpgpu_sim_wrapper.cc文件中找到了一个temp_ipc的变量

须知：
从gpu_sim_wrapper.cc的update_components_power的 *= voltage_ratio可以看到可以开启电压变换模式，使功耗受电压调节；即dvfs
问题：
gpu_IDLE_COREP 计算有问题
    这个功耗是在 power_interface.cc -> wrapper->compute();
                    processor.cc -> cores[i]->compute();
                        core.cc ->   IdleCoreEnergy = XML->sys.num_idle_cores * XML->sys.idle_core_power * executionTime;
    计算得到，构想是改为这个core活跃就设num_idle_cores为1，否则为0
        思路：获取活跃核心列表，在然后判断是否活跃，是就在power_interface.cc中将num_idle_core设置为0
        在gpu-sim.cc中可以获取到其列表。*active_sms += m_cluster[i]->get_n_active_sms();
    解决方案： 添加 lyhong_active_sms_list;如果核心活跃就将idle_core_number设置为0，否则1

修正idle_core后发现static_power出问题 
    static_power的计算函数（gpgpu_sim_wrapper.cc）看到，计算出的静态功耗在输出时乘以了一个活跃核心比例（模拟核心gate?）
*   目前采用的是直接除以核心数得到平均的静态功耗，也可以return总的，在输出的时候将其改为每个核心对应的静态功耗，模拟gate       
常量功耗constp是直接读取出来的

所有核心之和不等于直接计算的核心总和：
power_report里Dynamic Power Total的值应该等于gpu_CONSTP外的power总和

除第一个核心外，其他核心所有值相同,且应该是没有正确读取核心各种计算的power
    原因在于所有数据都在第一个wrapper[0]的power_stat中，后续的power_stat都为0
        原因在于power_stats->save_stats()清空数据了